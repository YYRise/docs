---
title: "并发"
date: 2021-07-16T11:18:10+08:00
draft: false
---

## 1. 原子操作和互斥锁的区别

- 互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。

- 原子操作是针对某个值的单个互斥操作。

- 可以把互斥锁理解为悲观锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。

## 2. channel和mutex的选择

- channel的能力是让数据流动起来，擅长的是数据流动的场景
- - 1. 传递数据的所有权，即把某个数据发送给其他协程
- - 2. 分发任务，每个任务都是一个数据
- - 3. 交流异步结果，结果是一个数据

- mutex的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景
- - 1. 缓存
- - 2. 状态

## 3. sync.map 的实现思路：

- 1. 读写分离。读（更新）相关的操作尽量通过不加锁的 read 实现，写（新增）相关的操作通过 dirty 加锁实现。
- 2. 动态调整。新写入的 key 都只存在 dirty 中，如果 dirty 中的 key 被多次读取，dirty 就会上升成不需要加锁的 read。
- 3. 延迟删除。Delete 只是把被删除的 key 标记成 nil，新增 key-value 的时候，标记成 enpunged；dirty 上升成 read 的时候，标记删除的 key 被批量移出 map。这样的好处是 dirty 变成 read 之前，这些 key 都会命中 read，而 read 不需要加锁，无论是读还是更新，性能都很高。